##########################################################################################
#               _/\/\/\/\/\____/\/\/\/\__/\/\/\/\/\____/\/\_______                       #
#               _/\/\____/\/\____/\/\____/\/\____/\/\__/\/\_______                       #
#               _/\/\/\/\/\______/\/\____/\/\____/\/\__/\/\_______                       #
#               _/\/\__/\/\______/\/\____/\/\____/\/\__/\/\_______                       #
#               _/\/\____/\/\__/\/\/\/\__/\/\/\/\/\____/\/\/\/\/\_                       #
#               __________________________________________________                       #
##########################################################################################
# Part of RIDL, the RUR IDL builder which generates modules for middlewares, including 
# lightweight (robotic) middleware like YARP. 
# This makefile is part of a cmake build system. The code falls under the Lesser General 
# Public License (LGPL GNU v3).

# Author:	 Anne C. van Rossum (Almende B.V.)
# Date: 	 Mar. 14, 2013
#
# ASCII Art generated by: http://www.network-science.de/ascii/ with font "ticks".
#
# Copyright Â© 2013 Anne van Rossum <anne@almende.com>
##########################################################################################

IF(WIN32)
  cmake_minimum_required(VERSION 2.6)
ELSE(WIN32)
  cmake_minimum_required(VERSION 2.4)
ENDIF(WIN32)

# The directory with all the FindXXX modules
SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/aim/cmake/")

MESSAGE("[*] Search for FindX files in ${CMAKE_SOURCE_DIR}/aim/cmake")

# The macro below forces the build directory to be different from source directory:
INCLUDE( MacroEnsureOutOfSourceBuild )
MACRO_ENSURE_OUT_OF_SOURCE_BUILD ( "[*] Requires an out of source build." ) 

# Build options
OPTION(BUILD_YARP      "Build module with YARP" OFF)
OPTION(BUILD_ROS       "Build module with ROS" OFF)
OPTION(BUILD_ZEROMQ    "Build module with ZeroMQ" OFF)
OPTION(BUILD_NODEJS    "Build module with NodeJS" OFF)
OPTION(BUILD_STANDARD  "Default build option" ON)

# Check first if on command line CMAKE has set one of the options
IF (NOT (BUILD_YARP OR BUILD_ROS OR BUILD_ZEROMQ OR BUILD_NODEJS))
  # If not, load the option from file
  MESSAGE("[*] Check ${CMAKE_SOURCE_DIR}/aim/local.cmake")
  IF (EXISTS "${CMAKE_SOURCE_DIR}/aim/local.cmake")
    MESSAGE("[*] Use user-defined local configuration file")
    INCLUDE(local.cmake)
  ELSE()
    MESSAGE("[*] Use default configuration file")
    INCLUDE(default.cmake)
  ENDIF()
ENDIF()

# Check again if one of the options has turned on from one of the .cmake files
IF (BUILD_YARP OR BUILD_ROS OR BUILD_ZEROMQ OR BUILD_NODEJS)
  SET(BUILD_STANDARD OFF)
ENDIF ()

INCLUDE(/etc/rur/backends.cmake)
INCLUDE(~/.rur/backends_path.cmake OPTIONAL)

# Set commands for header generation
IF (BUILD_YARP) 
  SET(MIDDLEWARE "yarp")
ENDIF ()

IF (BUILD_ROS) 
  SET(MIDDLEWARE "ros")
ENDIF ()

IF (BUILD_ZEROMQ) 
  SET(MIDDLEWARE "zeromq")
ENDIF ()

IF (BUILD_NODEJS) 
  SET(MIDDLEWARE "nodejs")
ENDIF ()

IF (BUILD_STANDARD) 
  SET(MIDDLEWARE "standard")
ENDIF ()

# Set files to be used or generated
SET(IDL_FILE "aim/idl/${PROJECT_NAME}.idl")
SET(HEADER_FILE "aim/inc/${PROJECT_NAME}.h")
SET(CPP_FILE "aim/inc/${PROJECT_NAME}.cpp")

# Actually generate the header files
MESSAGE("[*] Run the rur-builder with arguments: \"${IDL_FILE}\", \"${MIDDLEWARE}\", \"${BACKENDS_PATH}\", \"${HEADER_FILE}\"")
EXECUTE_PROCESS(COMMAND rur-builder ${IDL_FILE} ${MIDDLEWARE} ${BACKENDS_PATH} ${HEADER_FILE} WORKING_DIRECTORY ${CMAKE_SOURCE_DIR} )

# NodeJS requires a cpp file
IF (BUILD_NODEJS)
  MESSAGE("[*] Run the rur-builder with arguments: \"${IDL_FILE}\", \"${MIDDLEWARE}_cpp\", \"${BACKENDS_PATH}\", \"${CPP_FILE}\"")
  EXECUTE_PROCESS(COMMAND rur-builder ${IDL_FILE} ${MIDDLEWARE}_cpp ${BACKENDS_PATH} ${CPP_FILE} WORKING_DIRECTORY ${CMAKE_SOURCE_DIR} )
ENDIF ()

# Write the (backend) configuration
MESSAGE("[*] Generate aim/inc/Config.h file, that you can use in the code to know which middleware is in use")
CONFIGURE_FILE( ${CMAKE_SOURCE_DIR}/aim/config.h.cmake ${CMAKE_SOURCE_DIR}/aim/inc/Config.h )

# Find all cmake packages
IF (BUILD_YARP)
  MESSAGE("[*] YARP build, useful for YARP middleware")
  FIND_PACKAGE(YARP REQUIRED)
  INCLUDE_DIRECTORIES(${YARP_INCLUDE_DIRS} PARENT_SCOPE)
  SET(LIBS ${LIBS} ${YARP_LIBRARIES})
ENDIF (BUILD_YARP)

IF (BUILD_ROS)
  MESSAGE("[*] The project source dir: ${PROJECT_SOURCE_DIR}")
  IF ("$ENV{ROS_ROOT}" STREQUAL "") 
    MESSAGE(FATAL_ERROR "[*] Requires env. variable $ROS_ROOT. Run for example: \"source /opt/ros/groovy/setup.bash\".")
  ENDIF()
  MESSAGE("[*] ROS build, useful for ROS middleware")
  include($ENV{ROS_ROOT}/core/rosbuild/rosbuild.cmake)
  # http://www.ros.org/wiki/rosbuild/CMakeLists#rosbuild_init
  rosbuild_init()

  SET(INCLUDE_DIRS ${${PROJECT_NAME}_INCLUDE_DIRS})
  SET(INCLUDE_DIRS "$ENV{ROS_ROOT}/../../include")

  SET(LIBS ${LIBS} ${${PROJECT_NAME}_LIBRARIES})
  MESSAGE("[*] Libraries according to rosbuild_init: ${${PROJECT_NAME}_LIBRARIES}")
  MESSAGE("[*] Warning. Because these seem to be empty we will hardcode references to the libraries!")
  SET(LIBS ${LIBS} "$ENV{ROS_ROOT}/../../lib/libroscpp.so")
  SET(LIBS ${LIBS} "$ENV{ROS_ROOT}/../../lib/librosconsole.so")
  SET(LIBS ${LIBS} "$ENV{ROS_ROOT}/../../lib/libroscpp_serialization.so")
 
  SET(PARENT_INCLUDE_DIRS ${INCLUDE_DIRS} PARENT_SCOPE)
ENDIF (BUILD_ROS)

IF (BUILD_ZEROMQ)
  MESSAGE("[*] ZeroMQ build, useful for ZeroMQ message queues")
  FIND_PACKAGE(ZMQ REQUIRED)
  INCLUDE_DIRECTORIES(${ZMQ_INCLUDE_DIRS})
  SET(LIBS ${LIBS} ${ZMQ_LIBRARIES})

  FIND_PACKAGE(JsonSpirit REQUIRED)
  INCLUDE_DIRECTORIES(${JSON_SPIRIT_INCLUDE_DIRS})
  SET(LIBS ${LIBS} ${JSON_SPIRIT_LIBRARIES})

  # Currently tacitly assuming rt is always there...
  SET(LIBS ${LIBS} rt)
ENDIF (BUILD_ZEROMQ)

IF (BUILD_NODEJS)
  MESSAGE("[*] NodeJS build, compiles an addon")
  MESSAGE("[*] For now: use node-gyp to build")
ENDIF (BUILD_NODEJS)

# Source directory
SET(SOURCE_DIR "src")
SET(INCLUDE_DIR "inc")

# Set LIBS to PARENT_SCOPE OR LIBS here will not be "seen" by the parent CMakeLists.txt file
SET(LIBS ${LIBS} PARENT_SCOPE)

# Warning for user when standard build
IF (BUILD_STANDARD)
  MESSAGE("[*] Standard build, not usable in middleware yet")
ENDIF (BUILD_STANDARD)

# Search for functional source code
FILE(GLOB aim_source ${SOURCE_DIR}/*.cpp ${SOURCE_DIR}/*.cc ${SOURCE_DIR}/*.c)
FILE(GLOB aim_header ${INCLUDE_DIR}/*.hpp ${INCLUDE_DIR}/*.hh ${INCLUDE_DIR}/*.h)

SET(AIM_FILES ${aim_header} PARENT_SCOPE)

