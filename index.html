<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on http://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen"/>
  <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>AIM</title>
  <meta name="description" content="Artificial Intelligence Modules">

  <meta name="viewport" content="width=device-width,initial-scale=1">
</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">AIM</h1>
    </header>
    <div id="container">
      <p class="tagline">Artificial Intelligence Modules</p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/dobots/aim-bzr" class="code">View AIM on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          <h3>Welcome to AIM</h3>

<p>
AIM stands for Artificial Intelligence Modules, but is much more than that. AIM is inspired by three recent movements in practical computer science. First, in the robotics community there is a need for a wide range of functionalities, from computer vision, navigation and mapping, to sensor fusion, and machine learning, which lead to several <b>middlewares</b> that allow people to collaborate: <a href="http://eris.liralab.it/yarp">YARP</a> (Yet Another Robot Platform), <a href="http://www.ros.org">ROS</a> (Robot Operating System), <a href="http://www.urbiforge.org">URBI</a> (Universal Real-time Behavior Interface) to name a few. Second, there are <b>market</b> infrastructures to distribute your applications: <a href="https://play.google.com">Google play</a>, <a href="http://www.apple.com/iphone/from-the-app-store/">Apple app store</a>, and repositories like the <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad package archives</a> and the <a href="https://build.opensuse.org/">openSUSE build service</a>. Third, there are frameworks to allow you to implement or reveal functionality in the <b>cloud</b>, from <a href="http://www.zeromq.org/">ZeroMQ</a>, a distributed transport layer used in Twitter <a href="http://storm-project.net/">Storm</a>, to <a href="http://mahout.apache.org/">Mahout</a>, scalable Map/Reduce based machine learning libraries.</p>

<h3>Goal</h3>
<p>
The goal of AIM is threefold:
<ul>
<li>A <b>middleware-agnostic</b> modular approach to writing code: the <b>rur-builder</b>.</li>
<li>Tools to easily <b>create, publish, and cross-compile modules</b> that run as smoothly on robots as on servers: the <b>aimtools</b>.</li>
<li>A <b>distributed market place</b>, an app store for web developers: the <b>aimserver</b>.</li>
</ul>

</p>

<h3>Background</h3>
<p>
The <b>rur-builder</b> is loosely similar to <a href="http://homepages.laas.fr/mallet/soft/architecture/genom3">Genom3</a>. Just as Genom3 it is aimed to create an infrastructure of blocks of software that somehow know how to talk to each other. Genom3 and the rur-builder does not create some additional library that has to be linked to all middlewares (YARP, ROS, URBI, AgentScape, ZeroMQ, NodeJS) which quickly becomes a pain. In contrary, Genom3 and the rur-builder perform code generation. However, different from Genom3 using the rur-builder does not actually change the code itself. We do not "enrich" the code with meta-information. The meta-information is expected to be written down in an <b>IDL file</b>. This IDL file describes the interface of a module in a general sense. This means for example (contrary to Genom3) that code completion still works: there are no meta-statements (in TCL) through the code. This has multiple advantages. a.) The indexer just works. b.) A standard backend can be used for prototyping, not requiring any middleware. c.) Code generation in the headers can be extremely flexible, e.g. implementing topics for ROS, a concept totally absent in YARP. This is hard to achieve this flexibility by meta-statements in the code itself.</p>

<h3>Components</h3>
<p>
The current rur-builder provides functionality for different backends. Currently supported are <b>YARP</b>, <b>ROS</b>, <b>NodeJS</b>, and <b>ZeroMQ</b> as middleware between the different AI modules. To be able to use ZeroMQ as middleware solution a nameserver is implemented, called "zmqserver", and "zmqconnect", a connect utility (allowing exogenous coordination: start two modules separately and only later on connect them together).
</p>

<p>
The <b>aimtools</b> is a suite of tools in the same spirit as some of the tools in ROS, such as roscreate-pkg:
<ul>
<li><b>aimget</b>: add a github repository to your AIM workspace</li>
<li><b>aiminit</b>: create your own github repository in your AIM workspace</li>
<li><b>aimcreate-pkg</b>: create a new AI module</li>
<li><b>aimregister</b>: register the module locally</li>
<li><b>aimselect</b>: select a specific middleware to compile for</li>
<li><b>aimmake</b>: compile the module</li>
<li><b>aimcross</b>: cross-compile the module (currently supported: blackfin; upcoming: raspberry)</li>
<li><b>aimrun</b>: run a previously registered module</li>
<li><b>aimconnect</b>: connect two ports on running modules</li>
<li><b>aimstop</b>: register the module locally</li>
</ul>
</p>

<p>
The <b>aimserver</b> (forthcoming) is a REST server that allows people to find AI modules across a wide range of repositories. Moreover, it provides functionality to compile the code found, run it, stop it, and connect modules together. Towards that purpose there is a range of tools to create, register, copy, and connect AI modules: "aimtools".
</p>

<h3>Example</h3>
<p>
At <a href="https://github.com/dobots/aim_modules">AIM modules</a> you can find a ReadModule and a WriteModule that show how this framework operates. Both modules come with an IDL file (IDL stands for Interface Description Language). The <a href="https://raw.github.com/dobots/aim_modules/master/ReadModule/aim/idl/ReadModule.idl">IDL file</a> of the ReadModule does actually have only a few lines:</p>

<p>
<pre><code>#pragma copyright LGPLv3

// Recommended namespace "rur"
module rur {

// We want to be able to give our class a name
interface ReadModule {

  // Input from sensor as individual values
  void Input(in long input);

};
}</code></pre></p>

<p>
The important part here is the function "void Input" defined with an additional keyword: "in". This is transformed in a function description of which the following one shows the YARP-specific one:
</p>
<p><pre><code>inline int *readInput(bool blocking=true) {
  Bottle *b = portInput->read(blocking);
  if (b != NULL) { 
    portInputValue = b->get(0).asInt();
    return &portInputValue;
  }
  return NULL;
}</code></pre></p>

<p>
As you can see the generated code suddenly uses concepts that only mean something in YARP, such as an object called the "Bottle". You do not need to know anything about these if you are just using the function readInput(), which is exactly what is meant by AIM allowing you to write middleware-agnostic code. The other parts of the code also appear in the generated header file (not shown). The #pragma statements for example are transformed into comments and meant for author, copyright, date, and license information in the header.  The "module" keyword translates into a namespace.
</p>

<h3>Installation</h3>
<p>The installation instructions for the rur-builder and the aimtools can be found in detail on <a href="https://github.com/dobots/aimtools">github</a>. It boils down to make and sudo make install after cloning the github repositories and setting an environmental variable to the so-called AIM workspace. You can choose it where you want it to be (and update your shell accordingly).</p>

<p><pre><code>git clone --recursive https://github.com/dobots/aim.git
cd aim
make
sudo make install
mkdir $HOME/aim_workspace # Or some other dir
export AIM_WORKSPACE=$HOME/aim_workspace
echo "export AIM_WORKSPACE=$AIM_WORKSPACE" >> $HOME/.bashrc 
</code></pre></p>

<p>Now to get some modules, we need to clone a module repository. Towards this purpose we use aimget:</p>
<pre><code>aimget examples https://github.com/dobots/aim_modules
cd $AIM_WORKSPACE/examples
aimmake ReadModule
aimregister ReadModule
aimmake WriteModule
aimregister WriteModule
</code></pre></p>

<p>Now you have downloaded a bunch of modules that you subsequently can compile and run in different ways.</p>

<h4>Example with YARP</h4>

<p>The running of the code of these modules actually depends on the middleware you want to use it with. 
<!--Let us assume you installed the framework by using the <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad PPA</a> (see below). This means you can install YARP by apt-get. 
</p>
<p><pre><code>sudo apt-get install libyarp libyarp-dev yarp-bin
</code></pre></p>
-->
So <a href="http://wiki.icub.org/yarpdoc/install.html"> install YARP</a> first.
</p>

Let us assume you downloaded the robotics AI modules as mentioned above then:

<p><pre><code>cd $AIM_WORKSPACE/examples
aimselect ReadModule yarp
aimmake ReadModule
aimregister ReadModule
aimselect WriteModule yarp
aimmake WriteModule
aimregister WriteModule
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
yarp server
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun ReadModule 0 
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun WriteModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimconnect yarp WriteModule 0 output ReadModule 0 input
</code></pre></p>

<p>
This will use the YARP middleware to set up a TCP connection between the WriteModule and the ReadModule to send over a value. The "connect" utility needs to know which middleware is used, on the moment it will require a server to be run on the machine, but this requirement can be lifted for a distributed environment, as long as the specific "connect" implementations of the middleware knows how to find the registered ports.
</p>

<h4>Example with ZeroMQ</h4>

<p>
Running the code with ZeroMQ instead of YARP is along similar lines. To run the same WriteModule and ReadModule with ZeroMQ, you will need to:
</p>
<p><pre><code>sudo apt-get install libzmq-dev
sudo apt-get install libjson-spirit-dev
</code></pre></p>

Install the zmqserver, this requires <a href="https://github.com/joyent/node">Node.js to be installed</a>.
<p><pre><code>cd aim/zmqserver # From the dir where you cloned aim.git in
...
</code></pre></p>

<p><pre><code>cd $AIM_WORKSPACE/examples
aimselect ReadModule zeromq
aimmake ReadModule
aimregister ReadModule  # if not done before
aimselect WriteModule zeromq
aimmake WriteModule
aimregister WriteModule # if not done before
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
zmqserver
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun ReadModule 0 
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun WriteModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimconnect zeromq WriteModule 0 output ReadModule 0 input
</code></pre></p>

<p>
Like you can see there is a almost no different with the YARP example, but now there is suddenly made use of ZeroMQ channels rather than YARP ones. The difference exists out of starting the right name server "zmqserver" rather than "yarp server", and run aimconnect with "zeromq" instead of "yarp".
</p>

<h3>Create your own module</h3>

<p>
So, how to go about to create your own module? Suppose we want to create a module that receives a value on an input port and sends a moving average on its output port. And we are planning on building our own home automation software, so we call our own little repository "home_automation":
</p>

<p><pre><code>aiminit home_automation
cd $AIM_WORKSPACE/home_automation
aimcreate-pkg MovingAverageModule
# Now we compile our module, the default module already compiles!
aimmake MovingAverageModule</code></pre></p>

<p>
We are now going to make our changes to the code at three places. Open MovingAverageModule/aim-config/MovingAverageModule.idl with your favorite editor and make sure the interface definition looks like the following:
</p>

<p><pre><code>interface MovingAverageModule {
  void Input(in long input);
  
  void Average(out long output);
}</code></pre></p>

<p>
Adjust MovingAverageModule/inc/MovingAverageModuleExt.h to just add two private fields to the class (to count the messages, and to store the last average):
</p>

<p><pre><code>class MovingAverageModuleExt: public MovingAverageModule {
public:
  MovingAverageModuleExt(): message_counter(0), prev_average(0) { }
  virtual ~MovingAverageModuleExt() { }
  void Tick();
  bool Stop();
private:
  long int message_counter;
  double prev_average;
};
</code></pre></p>

<p>
Adapt MovingAverageModule/src/MovingAverageModuleExt.cpp subsequently:
</p>

<p>
<pre><code>void MovingAverageModuleExt::Tick() {
  int *value = readInput();
  if (value) {
    int i = ++message_counter;
    std::cout << "Messages received: " << i << std::endl;
    double average = (*value + prev_average*(i-1)) / i;
    std::cout << "Calculate (" << *value << "+" << prev_average << "*" << (i-1) << ") /" << i << "=" << average << std::endl;
    writeAverage(average);
    prev_average = average;
  }
  sleep(1); // Requires to #include <unistd.h>
}</code></pre>
</p>

<p>
<!--You can see that there is a call to the parent Tick() function, this is important to be able to receive messages. -->
The complete code you can find at the <a href="https://github.com/mrquincle/aim_modules/tree/master/MovingAverageModule">MovingAverageModule</a> on github. Running your example is in the same way as defined with the ReadModule and WriteModule example. Let us use the ZeroMQ backend (and assume that you followed the example above with the ReadModule and the WriteModule currently compiled for the ZeroMQ backend indeed):
</p>

<p><pre><code>cd $AIM_WORKSPACE/home_automation
aimselect MovingAverageModule zeromq
aimmake MovingAverageModule
aimregister MovingAverageModule
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
zmqserver
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun ReadModule 0 
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun WriteModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimrun MovingAverageModule 0
# go to a separate shell (Ctrl+Shift T in gnome-terminal)
aimconnect zeromq MovingAverageModule 0 average ReadModule 0 input
aimconnect zeromq WriteModule 0 output MovingAverageModule 0 input
</code></pre></p>

<p>
The output you can expect in the terminal with the MovingAverageModule (use Ctrl+Page Up/Down to navigate) is something like: "Messages 
received: 4" and "Calculate (1+2*3)/4=1.75". Let's upload your code to your own github repository!
</p>

<p><pre><code>cd $AIM_WORKSPACE
git add MovingAverageModule
git commit -m "A moving average module for the AIM repository"
git push
# And now you can push it to e.g. github 
git remote add origin git@github.com:yourname/somerepos.git
git push -u origin master
</code></pre></p>

<h3>How to get it?</h3>
<p>
You can get the code from <a href="https://github.com/dobots/aim-bzr">github.com</a>, but the easiest way to get the code is via <a href="https://launchpad.net/~dobots/+archive/ppa">Launchpad</a>:

<pre><code>sudo add-apt-repository ppa:dobots/ppa 
sudo apt-get update
sudo apt-get install aim
dpkg -L aim</code></pre></p>

<h3>Example of the tree layout of MovingAverageModule</h3>
<p>
To be completely transparent about how a module is organized, this is the complete listing of an AIM module except for the files generated in its builds/ directory. This listing is generated by: 
<pre><code>tree -H MovingAverageModule</code></pre>
Summarized, the aim-core files do not need modifications, the aim-config files will need so. By default they already contain templated text, which will make them compile. However, if you for example want to publish your module to be used by the Node package manager you might want to add some additional description in package.json for instance. We will automate this process more and more so you will need fewer places to do this over time.
</p>
<div class="tree">
	<p>
	<a href="MovingAverageModule">MovingAverageModule</a><br>
	├── <a href="./aim-config/">aim-config</a><br>
	│   ├── <a href="./aim-config/config.aim">config.aim</a><br>
	│   ├── <a href="./aim-config/MovingAverageModule.idl">MovingAverageModule.idl</a><br>
	│   ├── <a href="./aim-config/nodejs/">nodejs</a><br>
	│   │   ├── <a href="./aim-config/nodejs/binding.gyp">binding.gyp</a><br>
	│   │   ├── <a href="./aim-config/nodejs/MovingAverageModuleNode.cc">MovingAverageModuleNode.cc</a><br>
	│   │   └── <a href="./aim-config/nodejs/package.json">package.json</a><br>
	│   └── <a href="./aim-config/ros/">ros</a><br>
	│   &nbsp;&nbsp;&nbsp; ├── <a href="./aim-config/ros/manifest.xml">manifest.xml</a><br>
	│   &nbsp;&nbsp;&nbsp; └── <a href="./aim-config/ros/package.xml">package.xml</a><br>
	├── <a href="./aim-core/">aim-core</a><br>
	│   ├── <a href="./aim-core/cmake/">cmake</a><br>
	│   │   ├── <a href="./aim-core/cmake/FindJsonSpirit.cmake">FindJsonSpirit.cmake</a><br>
	│   │   ├── <a href="./aim-core/cmake/FindYARP.cmake">FindYARP.cmake</a><br>
	│   │   ├── <a href="./aim-core/cmake/FindZMQ.cmake">FindZMQ.cmake</a><br>
	│   │   ├── <a href="./aim-core/cmake/LibFindMacros.cmake">LibFindMacros.cmake</a><br>
	│   │   └── <a href="./aim-core/cmake/MacroEnsureOutOfSourceBuild.cmake">MacroEnsureOutOfSourceBuild.cmake</a><br>
	│   ├── <a href="./aim-core/CMakeLists.txt">CMakeLists.txt</a><br>
	│   ├── <a href="./aim-core/config.h.cmake">config.h.cmake</a><br>
	│   ├── <a href="./aim-core/inc/">inc</a><br>
	│   │   └── <a href="./aim-core/inc/MovingAverageModule.h">MovingAverageModule.h</a><br>
	│   ├── <a href="./aim-core/middleware_default.aim">middleware_default.aim</a><br>
	│   ├── <a href="./aim-core/middleware_name.sh">middleware_name.sh</a><br>
	│   └── <a href="./aim-core/src/">src</a><br>
	│   &nbsp;&nbsp;&nbsp; └── <a href="./aim-core/src/MovingAverageModule.cpp">MovingAverageModule.cpp</a><br>
	├── <a href="./aim-devel/">aim-devel</a><br>
	├── <a href="./binding.gyp">binding.gyp</a><br>
	├── <a href="./CMakeLists.txt">CMakeLists.txt</a><br>
	├── <a href="./inc/">inc</a><br>
	│   └── <a href="./inc/MovingAverageModuleExt.h">MovingAverageModuleExt.h</a><br>
	├── <a href="./Makefile">Makefile</a><br>
	├── <a href="./server.js">server.js</a><br>
	└── <a href="./src/">src</a><br>
	&nbsp;&nbsp;&nbsp; ├── <a href="./src/MovingAverageModuleExt.cpp">MovingAverageModuleExt.cpp</a><br>
	&nbsp;&nbsp;&nbsp; └── <a href="./src/MovingAverageModuleMain.cpp">MovingAverageModuleMain.cpp</a><br>
	</p>
</div>
</h3>

<h3>Support</h3>

<p>You would like to know more? Check out the company providing all this open-source software <a href="http://www.dobots.nl">Distributed Organisms B.V.</a>, a spinoff of the Dutch research institute <a href="http://www.almende.com">Almende</a>. The github repository of DO is called <a href="https://github.com/dobots" class="user-mention">dobots</a>. You can also checkout the repositories of individual authors <a href="https://github.com/vliedel" class="user-mention">Bart van Vliet</a>, <a href="https://github.com/eggerdo" class="user-mention">Dominik Egger</a> and <a href="https://github.com/mrquincle" class="user-mention">Anne van Rossum</a>.</p>
        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/mrquincle" class="avatar"><img src="https://secure.gravatar.com/avatar/36365a1f813c2fe401024f5d3552adaf?s=30&amp;d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-user-420.png" width="48" height="48"/></a> <a href="https://github.com/mrquincle">mrquincle</a> maintains <a href="https://github.com/mrquincle/aim-bzr">AIM</a></p>
      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br/>theme by <a href="http://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <p class="name"></p>
  </div>

  
</body>
</html>
